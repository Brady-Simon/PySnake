import torch
import torch.optim as optim
import torch.nn as nn
from Controllers.SnakeControllable import SnakeControllable
from Models.SnakeBoard import SnakeBoard
from Models.Snake import Snake
from Models.Direction import Direction

import matplotlib
matplotlib.use("TkAgg")  # Using TkAgg to prevent issues with Tkinter SnakeWindow
from matplotlib import pyplot as plt


class GenericSnakeAI(nn.Module, SnakeControllable):
    """A neural network that decides snake movements based on directions.

    Input lists should match the following structure:
     - Size X list
     - Direction of the point [0, 1, 1, 0] (length (4)
     - Direction snake is facing [1, 0, 0, 0] (length 4)
     - Vision around the snake (3x3 grid, 5x5 grid, etc.)

     The output from `forward()` is a 4-length tensor indicating the directions.
    """

    def __init__(self, vision_radius: int = 2, debug: bool = False):
        """Creates a `GenericSnakeAI`.

        Args:
            vision_radius (int): How far the snake can see in blocks.
            debug (bool): Whether or not to include diagnostic print statements.
        """
        super().__init__()
        self.vision_radius = vision_radius
        self.debug = debug
        self.lossHistory = []
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

        inputSize: int = 8 + (2 * vision_radius + 1) ** 2
        hiddenSize1 = int(inputSize * 3 / 8)
        hiddenSize2 = int(hiddenSize1 * 3 / 5)
        # 32 20 12 4
        self.hiddenLayer1 = nn.Linear(inputSize, hiddenSize1).to(self.device)
        self.hiddenLayer2 = nn.Linear(hiddenSize1, hiddenSize2).to(self.device)
        self.outputLayer = nn.Linear(hiddenSize2, 4).to(self.device)

    def forward(self, x):
        """Forwards tensor `x` through the neural network.

        Args:
            x (tensor): The tensor to forward.

        Returns:
            tensor: The value generated by the neural network.
        """
        x = self.hiddenLayer1(x)
        x = torch.relu(x)

        x = self.hiddenLayer2(x)
        x = torch.relu(x)

        x = self.outputLayer(x)
        x = torch.sigmoid(x)
        return x

    def nextDirection(self, snakeBoard: SnakeBoard, snakeName: str) -> Direction:
        """Returns the next move to use given `snakeBoard` and `snakeName`."""
        tensor = self.boardToTensor(snakeBoard, snakeName)
        tensorResult = self.forward(tensor)
        argmax = torch.argmax(tensorResult).item()
        return Direction.moves()[argmax]

    def boardToTensor(self, gameBoard: SnakeBoard, snakeName: str):
        """Converts a board to a usable Tensor for input into the ANN.

        Args:
            gameBoard (TicTacToeBoard): The board being converted to a tensor.
            snakeName (str): The name of the snake to control.

        Returns:
            tensor: A 27-length tensor that represents the locations of X, O, and empty spaces.
        """
        results = []
        # Append the directions to point
        pointDirections = gameBoard.directionsToPoint(pos=gameBoard.snakeDict.get(snakeName).head())
        results.extend([1.0 if direction in pointDirections else 0.0 for direction in Direction.moves()])
        # Append the current direction
        currentDirection = gameBoard.directionFor(snakeName=snakeName)
        results.extend([1.0 if currentDirection == direction else 0.0 for direction in Direction.moves()])
        # Append vision grid
        for y in range(-self.vision_radius, self.vision_radius + 1):
            for x in range(-self.vision_radius, self.vision_radius + 1):
                if not gameBoard.board.inBounds((x, y)):
                    results.append(0.0)
                elif not gameBoard.board.isEmpty((x, y)):
                    results.append(0.0)
                else:
                    results.append(1.0)
        # Return the resulting tensor
        return torch.Tensor(results).to(self.device)


def main():
    model = GenericSnakeAI()
    from Controllers.Genetics.GeneticTrainer import GeneticTrainer
    fitness_history = GeneticTrainer.train(model, steps=16, generations=64, workers=4, mutation_rate=0.2)

    figure = plt.gcf()
    figure.canvas.set_window_title("Genetic Training Results")
    plt.title(f"Fitness History")
    plt.grid(axis='y')
    plt.ylabel("Max Fitness")
    plt.xlabel("Generation")
    plt.plot(fitness_history)
    plt.show()

    from Views.SnakeWindow import SnakeWindow

    def get_board():
        snakeBoard = SnakeBoard()
        snake = Snake(name='AI', mark='X',
                      segments=[(snakeBoard.board.columns() // 2, snakeBoard.board.rows() - 3),
                                (snakeBoard.board.columns() // 2, snakeBoard.board.rows() - 2),
                                (snakeBoard.board.columns() // 2, snakeBoard.board.rows() - 1)],
                      controller=model, maxHealth=50)
        snakeBoard.addSnake(snake)
        snakeBoard.generatePoint()
        return snakeBoard

    board = get_board()
    window = SnakeWindow(snakeBoard=board, humanControllable=False, fps=7, reset_func=get_board)
    window.mainloop()


if __name__ == '__main__':
    main()
