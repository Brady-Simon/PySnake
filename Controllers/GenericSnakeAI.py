import torch
import torch.nn as nn
from Controllers.SnakeControllable import SnakeControllable
from Models.SnakeBoard import SnakeBoard
from Models.Snake import Snake
from Models.Direction import Direction
from Controllers.VisionNeuralNetwork import VisionNeuralNetwork
import time

import matplotlib
matplotlib.use("TkAgg")  # Using TkAgg to prevent issues with Tkinter SnakeWindow
from matplotlib import pyplot as plt


class GenericSnakeAI(nn.Module, SnakeControllable):
    """A neural network that decides snake movements based on directions.

    Input lists should match the following structure:
     - Size X list
     - Direction of the point [0, 1, 1, 0] (length (4)
     - Direction snake is facing [1, 0, 0, 0] (length 4)
     - Vision around the snake (3x3 grid, 5x5 grid, etc.)

     The output from `forward()` is a 4-length tensor indicating the directions.
    """

    def __init__(self, vision_radius: int = 2, debug: bool = False):
        """Creates a `GenericSnakeAI`.

        Args:
            vision_radius (int): How far the snake can see in blocks.
            debug (bool): Whether or not to include diagnostic print statements.
        """
        super().__init__()
        self.vision_radius = vision_radius
        self.debug = debug
        self.lossHistory = []
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

        inputSize: int = 36
        hiddenSize1 = 24
        hiddenSize2 = 12
        outputSize = 4
        self.inputLayer = nn.Linear(inputSize, hiddenSize1)
        self.hiddenLayer = nn.Linear(hiddenSize1, hiddenSize2)
        self.outputLayer = nn.Linear(hiddenSize2, outputSize)

    def forward(self, x):
        """Forwards tensor `x` through the neural network.

        Args:
            x (tensor): The tensor to forward.

        Returns:
            tensor: The value generated by the neural network.
        """
        x = self.inputLayer(x)
        x = torch.relu(x)

        x = self.hiddenLayer(x)
        x = torch.relu(x)

        x = self.outputLayer(x)
        x = torch.sigmoid(x)
        return x

    def nextDirection(self, snakeBoard: SnakeBoard, snakeName: str) -> Direction:
        """Returns the next move to use given `snakeBoard` and `snakeName`."""
        tensor = self.boardToTensor(snakeBoard, snakeName)
        tensorResult = self.forward(tensor)
        argmax = torch.argmax(tensorResult).item()
        return Direction.moves()[argmax]

    def boardToTensor(self, gameBoard: SnakeBoard, snakeName: str):
        """Converts a board to a usable Tensor for input into the ANN.

        Args:
            gameBoard (TicTacToeBoard): The board being converted to a tensor.
            snakeName (str): The name of the snake to control.

        Returns:
            tensor: A 36-length tensor.
        """
        result = []
        # Add the snake's current direction (4)
        result.extend([1.0 if gameBoard.directionFor(snakeName) == direction
                       else 0.0 for direction in Direction.moves()])
        # Add the safe directions (4)
        safeDirections = gameBoard.safeDirections(snakeName)
        result.extend([1.0 if direction in safeDirections else 0.0 for direction in Direction.moves()])
        # Add the direction to the point (4)
        directionsToPoint = gameBoard.directionsToPoint(gameBoard.snakeDict.get(snakeName).head())
        result.extend([1.0 if direction in directionsToPoint else 0.0 for direction in Direction.moves()])
        # Add the vision around snake (8x3=24)
        visionDeltas = [(0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1)]
        head = gameBoard.snakeDict.get(snakeName).head()
        for delta in visionDeltas:
            result.extend(self.visionTo(gameBoard, head, delta))
        return torch.Tensor(result)

    @staticmethod
    def visionTo(snakeBoard, head, delta) -> list:
        result = [0.0, 0.0, 0.0]  # Food, body, empty/wall
        pos = head
        distance = 0
        while snakeBoard.board.inBounds(pos):
            pos = (pos[0] + delta[0], pos[1] + delta[1])
            distance += 1
            if snakeBoard.point == pos:
                result[0] = 1.0
            elif not snakeBoard.board.isEmpty:
                result[1] = 1.0
            # elif snakeBoard.board.isEmpty(pos):
            #     result[2] = 1.0
        result[2] = 1 / distance
        return result


def main():
    from Controllers.Genetics.GeneticTrainer import GeneticTrainer
    from Views.SnakeWindow import SnakeWindow

    file_name = 'genetic_state_dict'

    def get_model():
        return GenericSnakeAI()

    def get_board(controller, adaptiveHealth: bool = False):
        snakeBoard = SnakeBoard()
        segments = GeneticTrainer.generateSnakeSegments(snakeBoard.board,
                                                        snakeBoard.board.columns(),
                                                        snakeBoard.board.rows())
        snake = Snake(name='AI', mark='X',
                      segments=segments,
                      controller=controller,
                      maxHealth=20 if adaptiveHealth else 50,
                      healthIncrease=2 if adaptiveHealth else 0)
        snakeBoard.addSnake(snake)
        snakeBoard.generatePoint()
        return snakeBoard

    model = GenericSnakeAI()
    looping = True
    while looping:
        answer = input("Use a new model or load existing one? <1|2>: ")
        if answer.lower() == '1':
            # Model is already created and randomized; just exit the loop
            looping = False
        elif answer.lower() == '2':
            # Load the existing state dictionary from file
            model.load_state_dict(torch.load(file_name))
            looping = False
        else:
            print("Input not recognized.")

    looping = True
    while looping:
        answer = input("Would you like to train the model or play? <1|2>: ")
        if answer == '1':
            # Train new model
            start_time = time.time()
            state_dict, fitness_history = GeneticTrainer.startSimulation(get_model,
                                                                         initial_state_dict=model.state_dict(),
                                                                         population=1024, generations=512,
                                                                         mutation_rate=0.0005,
                                                                         cutoff_fitness=8000,
                                                                         timeout=None)
            end_time = time.time()
            model.load_state_dict(state_dict)
            print("Training time: {0:.1f} seconds".format(end_time - start_time))

            # Show the fitness history
            figure = plt.gcf()
            figure.canvas.set_window_title("Genetic Training Results")
            plt.title(f"Fitness History")
            plt.grid(axis='y')
            plt.ylabel("Max Fitness")
            plt.xlabel("Generation")
            plt.plot(fitness_history)
            plt.show()

            # Play the game
            board = get_board(model)
            window = SnakeWindow(snakeBoard=board, humanControllable=False, fps=7, reset_func=lambda: get_board(model))
            window.mainloop()

            # Ask to save the trained model.
            while True:
                shouldSaveModel = input("Would you like to save the model? (y/n): ")
                if shouldSaveModel.lower() == 'y':
                    torch.save(state_dict, file_name)
                    break
                elif shouldSaveModel.lower() == 'n':
                    print("Exiting...")
                    break
                else:
                    print("Input not recognized.")
            looping = False
        elif answer == '2':
            # Play the game and don't train
            board = get_board(model)
            window = SnakeWindow(snakeBoard=board, humanControllable=False, fps=7, reset_func=lambda: get_board(model))
            window.mainloop()
            looping = False


if __name__ == '__main__':
    main()
